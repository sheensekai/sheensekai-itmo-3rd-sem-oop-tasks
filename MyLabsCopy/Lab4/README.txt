В моей модели получается, что один и тот же магазин может иметь
несколько объектов Shop, т.е разные ссылки, которые просто ссылочно
друг с другом не сравнить(т.к на каждый запрос DAO новый Shop)
=> оператор сравнения. Правильно ли было
решить проблему, либо нужно было не работать с товарами\магазинами
как с классами, либо было еще какое-то решение лучше?

Я сделал целых три класса для продуктов: имя\тип, имя\тип+кол-во, имя\тип+кол-во+цена
Плохо ли это? Если да, то по какой причине? Как лучше можно было бы смоделировать продукты,
чтобы можно было использовать все три типа продуктов в коде? Один обобщенный с обнуленными
полями?

Я использую структуры Product и Shop на всех трех слоях. Правильно ли это?
Т.е у меня в интерфейсах и реализациях испольлзуются эти структуры, что
подразумевает, что все три слоя знают об этих структурах и должны использовать
именно их. Не влияет ли это как-то на разделенность и независимость эти трех
слоев(в чем, вроде бы, и смысл трехуровневой архитектуры)

Я сделал у ДАО интерфейс как у конкретной базы данных магазинов. Правильно ли это?
Я клоню к тому, что допустим можно было сделать обобщенный интерфейс, который бы
предполагал, что ДАО - это ЛЮБАЯ база данных. Таким образом объект, реализ. ДАО
бы работал с КАКОЙ-ТО бд, что означало бы, что слой менеджмента мог бы работать
через интерфейс ДАО с несколькими разными базами данных. Но это в свою очередь
бы привело к тому, что интерфейс у Дао был бы самый общий - достать эту строчку
из этого столбца и подобные. Значит, такая задумка неправильна, ведь о внутряке
бд должен знать только сам слой ДАО, а не слой, работающий с его(ДАО) интерфейсом?
Либо, допустим, можно было бы сделать еще один полуслой, который бы представлял
какую-то определнную бд, а сам использовал ДАО - обобщенную бд. Это плохая задумка?
Почему?




bool DelShop(Shop shop);
bool DelShop(string name);
Shop GetShop(string name);
AProduct AddProduct(AProduct product);
bool DelProduct(AProduct product);
Product GetProduct(string shop, string type, string name);
Product GetProduct(Shop shop, AProduct product);
List<Pair<Shop, Product>> GetProduct(AProduct product);
List<Pair<Shop, Product>> GetProduct(string type, string name);
List<Product> GetProducts(Shop shop);
void UpdateProduct(Shop shop, List<AProduct> products, List<UpdateQuery> queries);
void UpdateProduct(List<Shop> shops, AProduct product, List<UpdateQuery> queries);
void UpdateProduct(List<Shop> shops, List<AProduct> products, List<List<UpdateQuery>> queries_for_every_shop);